'''
Վարժություն 1.1
Ի՞նչ կպատասխանի ինտերպրետատորը ներքևում գրված արտահայտություններից յուրաքանչյուրին


>>> 10
10
>>> 5 + 3 + 12
20
>>> 9 - 2
7
>>> 20 / 2
10
>>> (4 * 2) - (2 * 3)
2
>>> a = 3
>>> b = a + 1
>>> a + b + (a * b)
19


Վարժություն 1.2

Պատկերեք հետևյալ արտահայտությունը ծառի տեսքով
(5 + 3) * (((10 / 2) - 1) * (2 * 4))

'''

'''
    Վարժություն 1.3
    Ստեղծեք ֆունկցիա, որը որպես արգումենտ ստանում
    է երեք թվեր և վերադարձնում է դրանցից երկու
    մեծագույնների քառակուսիների գումարը։
'''

def a_b_c(a,b,c):
  if a < b and a < c:
    return b**2 + c**2
  elif b < a and b < c:
    return a**2 + c**2
  else:
    return a**2 + b**2

'''
    Վարժություն 1.4
    Նկարագրեք հետևյալ ֆունկցիայի աշխատանքը
'''

def a_plus_abs_b(a, b):
  if b > 0:
    return a + b
  else:
    return a - b
  
#   Այստեղ ֆունկցիան տեսնում է, եթե b-ն մեծ ա 0-ից տպուոմ է a + b , բայց եթե B-ն փոքր ա 0-ից տպում է a - b
#   Ինչո՞վ է այն տարբերվում հետևյալ սահմանումից

def a_plus_abs_b(a, b):
  if b > 0:
		return a + b
	return a - b

#    Այստեղ եթե b-ն մեծ ա 0-ից տպում ա a + b  և դուրս 
#    ա գալիս ցիկլից։ Բայց եթե b-ն 0-ից փոքր լինի կտպի միայն a - b:
#    Այս տարբերակը այնքան էլ ակտուալ չէ, քանի որ եթե այս կոդը
#    ֆունկցիաից դուրս գրած լինեինք ապա b > 0 -ի դեպքում 
#    կտպեր a + b և a - b (retunr-ի փոխարեն իհարկե print )

'''
    Վարժություն 1.5
    Ստեղծել ֆունկցիա, որը ստանում է երկու թվային արգումենտ` a և b, և 
    վերադարձնում է a-ից մինչև b ընկած ամբողջ թվերի գումարը։
    Կարող եք ենթադրել, որ առաջին արգումենտը միշտ փոքր է երկրորդից։
'''

def a_Plus_b(a,b):
  sum = 0
  while a <= b:
    sum += a
    a += 1
    return sum

'''
    Վարժություն 1.6
    Իրականացնել նախորդ վարժությունում տրված ֆունկցիան՝ հաշվի առնելով,
    որ առաջին արգումենտը կարող է մեծ լինել երկրորդից։ 
    Այդ դեպքում ֆունկցիան պետք է վերադարձնի b-ից մինչև a ամբողջ թվերի գումարը։
'''

def a_Plus_b(a,b):
  sum = 0
  if a < b:
    while a <= b:
      sum += a
      a += 1
      return sum
    else:
      while b <= a:
        sum += b
        b += 1
        return sum
        
'''
    Վարժություն 1.7
    Իրականացնել pow(a, b) ֆունկցիան՝ հաշվի առնելով, որ b-ն կարող է լինել նաև ոչ դրական։ Հիշեցնենք
'''
#    a ** b = a ** b, եթե a > 0
#    a ** b = (1 / a ** (-b)), եթե b < 0
#    a ** b = 1, եթե b = 0


def pow(a,b):
    if a > 0:
        return a**b
    elif b < 0:
        return (1 / a ** (-b))
    elif b == 0:
        return 1


#   Նաև հաշվի առեք, որ a-ի b աստիճանը սխալ արտահայտություն է, եթե a-ն հավասար է 0, իսկ b-ն բացասական է

def pow(a,b):
  if a == 0 and b < 0:
    return "is a wrong expression"
  elif a >= 0:
    return a**b
  elif b < 0:
    return (1 / a ** (-b))
  elif b == 0:
    return 1
